# Notifications

Learn how to configure and manage notifications programmatically using the Kadoa SDK. This guide covers real-time monitoring, channel setup, and integration with your workflows.

## Prerequisites

To get the most out of this guide, you'll need to:
- Create a Kadoa account
- Get your API key
- (Optional) Have a workflow for workflow-specific notifications

## Quick Start

Here's a simple example showing real-time WebSocket notifications with an extraction:

```typescript
import { KadoaClient } from '@kadoa/node-sdk';

const client = new KadoaClient({
  apiKey: 'your-api-key',
  enableRealtime: true // Enable WebSocket connection
});

// Listen to all events in real-time
client.realtime?.onEvent((event) => {
  console.log('Event received:', event.type, event.data);
});

// Run extraction with notifications
const result = await client.extraction.run({
  urls: ['https://sandbox.kadoa.com/ecommerce'],
  name: 'Product Extraction',
  notifications: {
    events: 'all', // Subscribe to all events
    channels: {
      WEBSOCKET: true // Use WebSocket channel
    }
  }
});

// Events will be received in real-time via the event listener
```

## Notification Channels

Kadoa supports four types of notification channels:

| Channel Type | Description | Use Case |
|-------------|-------------|----------|
| **WEBSOCKET** | Real-time browser/app notifications | Live dashboards, instant alerts |
| **EMAIL** | Email notifications | Reports, summaries, async updates |
| **SLACK** | Slack workspace messages | Team collaboration, alerts |
| **WEBHOOK** | HTTP callbacks to your endpoint | System integration, custom processing |

### Default vs Custom Channels

**Default Channels:**
- Created automatically when you use `true` in channel configuration
- Use your account's default settings (e.g., your email for EMAIL channels)
- Named "default" by default

**Custom Channels:**
- Created with specific configurations
- Can have custom names for organization
- Support advanced options (custom recipients, auth, etc.)

## Channel Types

### WebSocket Notifications (Real-time)

Real-time notifications delivered instantly via WebSocket connection.

```typescript
// Enable real-time connection
const client = new KadoaClient({
  apiKey: 'your-api-key',
  enableRealtime: true
});

// Listen to all events
client.realtime?.onEvent((event) => {
  switch (event.type) {
    case 'workflow_started':
      console.log('Workflow started');
      break;
    case 'workflow_finished':
      console.log('Workflow completed:', event.data);
      break;
    case 'workflow_data_change':
      console.log('New data detected');
      break;
    case 'workflow_failed':
      console.error('Workflow failed:', event.data);
      break;
    case 'workflow_sample_finished':
      console.log('Sample extraction finished');
      break;
  }
});

// Check connection status
if (client.isRealtimeConnected()) {
  console.log('Connected to real-time updates');
}

// Use WebSocket in extraction
await client.extraction.run({
  urls: ['https://example.com'],
  notifications: {
    events: 'all',
    channels: {
      WEBSOCKET: true
    }
  }
});
```

### Email Notifications

Send notifications to email addresses.

```typescript
// Use default user email
await client.notification.setupForWorkflow({
  workflowId: 'your-workflow-id',
  events: ['workflow_finished', 'workflow_failed'],
  channels: {
    EMAIL: true // Uses your account email
  }
});

// Custom email recipients
await client.notification.setupForWorkflow({
  workflowId: 'your-workflow-id',
  events: ['workflow_finished'],
  channels: {
    EMAIL: {
      name: 'team-notifications',
      recipients: ['team@example.com', 'alerts@example.com']
    }
  }
});

// Custom from address (must end with @kadoa.com)
await client.notification.setupForWorkflow({
  workflowId: 'your-workflow-id',
  events: ['workflow_finished'],
  channels: {
    EMAIL: {
      name: 'branded-notifications',
      recipients: ['team@example.com'],
      from: 'noreply@kadoa.com'
    }
  }
});
```

### Slack Notifications

Send notifications to Slack channels.

```typescript
// Create Slack channel with webhook URL
await client.notification.setupForWorkflow({
  workflowId: 'your-workflow-id',
  events: ['workflow_finished', 'workflow_failed'],
  channels: {
    SLACK: {
      name: 'engineering-alerts',
      webhookUrl: 'https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK'
    }
  }
});

// Reuse existing Slack channel
await client.notification.setupForWorkflow({
  workflowId: 'another-workflow-id',
  events: ['workflow_finished'],
  channels: {
    SLACK: { channelId: 'existing-channel-id' }
  }
});
```

### Webhook Notifications

Send HTTP requests to your custom endpoint.

```typescript
// Basic webhook
await client.notification.setupForWorkflow({
  workflowId: 'your-workflow-id',
  events: ['workflow_finished'],
  channels: {
    WEBHOOK: {
      name: 'api-integration',
      url: 'https://api.example.com/webhooks/kadoa',
      httpMethod: 'POST'
    }
  }
});

// Webhook with authentication
await client.notification.setupForWorkflow({
  workflowId: 'your-workflow-id',
  events: ['workflow_finished', 'data_changed'],
  channels: {
    WEBHOOK: {
      name: 'secure-webhook',
      url: 'https://api.example.com/webhooks/kadoa',
      httpMethod: 'POST',
      auth: {
        type: 'bearer',
        token: 'your-bearer-token'
      }
    }
  }
});

// Webhook with custom headers
await client.notification.setupForWorkflow({
  workflowId: 'your-workflow-id',
  events: ['workflow_finished'],
  channels: {
    WEBHOOK: {
      name: 'custom-headers-webhook',
      url: 'https://api.example.com/webhooks/kadoa',
      httpMethod: 'POST',
      headers: {
        'X-Custom-Header': 'value',
        'X-API-Key': 'your-api-key'
      }
    }
  }
});
```

## Notification Setup Patterns

### Inline Setup (Quick)

Set up notifications directly when running an extraction:

```typescript
// Quick notification setup
const result = await client.extraction.run({
  urls: ['https://example.com'],
  name: 'Product Extraction',
  notifications: {
    events: 'all',
    channels: {
      WEBSOCKET: true,
      EMAIL: true
    }
  }
});

// This automatically creates channels and settings for this workflow
```

### Workflow-Specific Notifications

Set up notifications for a specific workflow:

```typescript
// Setup notifications for a specific workflow
await client.notification.setupForWorkflow({
  workflowId: 'your-workflow-id',
  events: ['workflow_finished', 'workflow_failed'],
  channels: {
    EMAIL: true,
    SLACK: {
      name: 'project-alerts',
      webhookUrl: 'https://hooks.slack.com/services/YOUR/WEBHOOK'
    }
  }
});
```

### Workspace-Level Notifications

Set up notifications for all workflows in your workspace:

```typescript
// Setup notifications at workspace level (applies to all workflows)
await client.notification.setupForWorkspace({
  events: ['workflow_failed', 'error'],
  channels: {
    EMAIL: {
      name: 'workspace-alerts',
      recipients: ['admin@example.com', 'team@example.com']
    }
  }
});
```

## Event Types

### Available Events

Get a list of all available notification events:

```typescript
const availableEvents = await client.notification.settings.listAllEvents();
console.log('Available events:', availableEvents);
// Example output: ['workflow_started', 'workflow_finished', 'workflow_failed', 'workflow_data_change', ...]
```

### Common Event Types

| Event | Description | When to Use |
|-------|-------------|-------------|
| `workflow_started` | Workflow extraction started | Progress tracking |
| `workflow_finished` | Workflow completed successfully | Success notifications |
| `workflow_failed` | Workflow failed | Error alerts |
| `workflow_data_change` | New or updated data detected | Data monitoring |
| `workflow_sample_finished` | Sample extraction completed | Preview notifications |
| `system_maintenance` | System maintenance scheduled | Infrastructure alerts |
| `service_degradation` | Service performance issues | Monitoring alerts |
| `credits_low` | Account credits running low | Billing notifications |
| `free_trial_ending` | Free trial period ending soon | Billing notifications |

### Event Filtering

```typescript
// Subscribe to all events
await client.notification.setupForWorkflow({
  workflowId: 'your-workflow-id',
  events: 'all',
  channels: { WEBSOCKET: true }
});

// Subscribe to specific events only
await client.notification.setupForWorkflow({
  workflowId: 'your-workflow-id',
  events: ['workflow_finished', 'workflow_failed'],
  channels: { EMAIL: true }
});

// Different events for different channels
await client.notification.setupForWorkflow({
  workflowId: 'your-workflow-id',
  events: ['workflow_finished'],
  channels: { EMAIL: true }
});

await client.notification.setupForWorkflow({
  workflowId: 'your-workflow-id',
  events: ['workflow_failed', 'workflow_data_change'],
  channels: { SLACK: { channelId: 'slack-channel-id' } }
});
```

## Channel Management

### Listing Channels

```typescript
// List all workspace-level channels
const workspaceChannels = await client.notification.channels.listChannels({});

// List workflow-specific channels
const workflowChannels = await client.notification.channels.listChannels({
  workflowId: 'your-workflow-id'
});

// List all channels (workspace + workflow)
const allChannels = await client.notification.channels.listAllChannels('your-workflow-id');

console.log('Channels:', allChannels.map(c => ({
  id: c.id,
  name: c.name,
  type: c.channelType
})));
```

### Reusing Channels

```typescript
// Create a channel once
const channels = await client.notification.channels.listChannels({});
const emailChannel = channels.find(c => c.channelType === 'EMAIL');

// Reuse the channel across multiple workflows
await client.notification.setupForWorkflow({
  workflowId: 'workflow-1',
  events: ['workflow_finished'],
  channels: {
    EMAIL: { channelId: emailChannel.id }
  }
});

await client.notification.setupForWorkflow({
  workflowId: 'workflow-2',
  events: ['workflow_finished'],
  channels: {
    EMAIL: { channelId: emailChannel.id }
  }
});
```

### Deleting Channels

```typescript
// Delete a specific channel
await client.notification.channels.deleteChannel('channel-id');

// Clean up all channels
const channels = await client.notification.channels.listChannels({});
for (const channel of channels) {
  if (channel.id) {
    await client.notification.channels.deleteChannel(channel.id);
  }
}
```

## Managing Notification Settings

### Listing Settings

```typescript
// List all notification settings
const allSettings = await client.notification.settings.listSettings({});

// List settings for a specific workflow
const workflowSettings = await client.notification.settings.listSettings({
  workflowId: 'your-workflow-id'
});

// List settings for a specific event type
const eventSettings = await client.notification.settings.listSettings({
  eventType: 'workflow_finished'
});
```

### Deleting Settings

```typescript
// Delete a specific notification setting
await client.notification.settings.deleteSettings('setting-id');

// Clean up all settings for a workflow
const settings = await client.notification.settings.listSettings({
  workflowId: 'your-workflow-id'
});

for (const setting of settings) {
  if (setting.id) {
    await client.notification.settings.deleteSettings(setting.id);
  }
}
```

## Integration Examples

### CI/CD Pipeline Notifications

```typescript
// Setup notifications for deployment monitoring
async function setupDeploymentNotifications(workflowId: string) {
  await client.notification.setupForWorkflow({
    workflowId,
    events: ['workflow_finished', 'workflow_failed'],
    channels: {
      WEBHOOK: {
        name: 'ci-cd-webhook',
        url: process.env.CI_WEBHOOK_URL,
        httpMethod: 'POST',
        auth: {
          type: 'bearer',
          token: process.env.CI_WEBHOOK_TOKEN
        }
      },
      SLACK: {
        name: 'deployment-alerts',
        webhookUrl: process.env.SLACK_WEBHOOK_URL
      }
    }
  });
}
```

### Real-time Dashboard

```typescript
// Setup real-time monitoring for a dashboard
const client = new KadoaClient({
  apiKey: 'your-api-key',
  enableRealtime: true
});

// Track extraction progress
const progress = {
  started: false,
  completed: false,
  hasErrors: false
};

client.realtime?.onEvent((event) => {
  switch (event.type) {
    case 'workflow_started':
      progress.started = true;
      updateDashboard(progress);
      break;
    case 'workflow_finished':
      progress.completed = true;
      updateDashboard(progress);
      break;
    case 'workflow_failed':
      progress.hasErrors = true;
      updateDashboard(progress);
      break;
  }
});

function updateDashboard(progress) {
  // Update your dashboard UI
  console.log('Dashboard updated:', progress);
}
```

### Multi-Channel Notifications

```typescript
// Setup notifications across multiple channels
await client.notification.setupForWorkflow({
  workflowId: 'critical-workflow',
  events: ['workflow_finished', 'workflow_failed', 'workflow_data_change'],
  channels: {
    WEBSOCKET: true, // Real-time in-app notifications
    EMAIL: {
      name: 'critical-alerts',
      recipients: ['oncall@example.com', 'team@example.com']
    },
    SLACK: {
      name: 'critical-channel',
      webhookUrl: process.env.SLACK_WEBHOOK_URL
    },
    WEBHOOK: {
      name: 'monitoring-system',
      url: 'https://monitoring.example.com/webhooks',
      httpMethod: 'POST'
    }
  }
});
```

### Conditional Notifications

```typescript
// Setup different notifications based on workflow type
async function setupSmartNotifications(workflowId: string, workflowType: string) {
  if (workflowType === 'production') {
    // Production: all channels, all events
    await client.notification.setupForWorkflow({
      workflowId,
      events: 'all',
      channels: {
        EMAIL: true,
        SLACK: { channelId: 'prod-slack-channel' },
        WEBSOCKET: true
      }
    });
  } else if (workflowType === 'staging') {
    // Staging: only errors and failures
    await client.notification.setupForWorkflow({
      workflowId,
      events: ['workflow_failed', 'workflow_data_change'],
      channels: {
        SLACK: { channelId: 'staging-slack-channel' }
      }
    });
  } else {
    // Development: minimal notifications
    await client.notification.setupForWorkflow({
      workflowId,
      events: ['workflow_failed'],
      channels: {
        WEBSOCKET: true
      }
    });
  }
}
```

## Best Practices

### Use Descriptive Channel Names

```typescript
// Good: Descriptive names
await client.notification.setupForWorkflow({
  workflowId: 'workflow-id',
  events: ['workflow_finished'],
  channels: {
    EMAIL: {
      name: 'production-success-alerts',
      recipients: ['team@example.com']
    }
  }
});

// Avoid: Generic names
await client.notification.setupForWorkflow({
  workflowId: 'workflow-id',
  events: ['workflow_finished'],
  channels: {
    EMAIL: {
      name: 'email1',
      recipients: ['team@example.com']
    }
  }
});
```

### Reuse Channels When Possible

```typescript
// Efficient: Create channel once, reuse across workflows
const channels = await client.notification.channels.listChannels({});
const teamEmailChannel = channels.find(
  c => c.channelType === 'EMAIL' && c.name === 'team-alerts'
);

if (teamEmailChannel) {
  // Reuse existing channel
  await client.notification.setupForWorkflow({
    workflowId: 'workflow-1',
    events: ['workflow_finished'],
    channels: {
      EMAIL: { channelId: teamEmailChannel.id }
    }
  });
}
```

### Filter Events Appropriately

```typescript
// Good: Only subscribe to relevant events
await client.notification.setupForWorkflow({
  workflowId: 'workflow-id',
  events: ['workflow_failed', 'workflow_data_change'], // Only errors and data changes
  channels: { EMAIL: true }
});

// Avoid: Too many notifications
await client.notification.setupForWorkflow({
  workflowId: 'workflow-id',
  events: 'all', // May cause notification fatigue
  channels: { EMAIL: true }
});
```

### Handle Real-time Connection Errors

```typescript
const client = new KadoaClient({
  apiKey: 'your-api-key',
  enableRealtime: true
});

// Check connection before relying on events
if (!client.isRealtimeConnected()) {
  console.warn('WebSocket not connected, falling back to polling');
  // Implement fallback logic
}

// Handle events with error checking
client.realtime?.onEvent((event) => {
  try {
    // Process event
    console.log('Event:', event);
  } catch (error) {
    console.error('Error processing event:', error);
  }
});
```

## Getting Help

If you're stuck:
1. **Check the examples** in this documentation
2. **Browse the GitHub examples** in `/examples/node-examples/src/`
3. **Search GitHub Issues**
4. **Contact support** at support@kadoa.com

## Next Steps

- Learn about [Data Validation](./DATA_VALIDATION_GUIDE) for quality monitoring
- Explore [Validation Rules](./VALIDATION_RULES_GUIDE) for custom validation
- Check out [Schema Management](./SCHEMA_SDK_GUIDE) for defining data structures
- Review [Getting Started](../sdks/introduction) for extraction basics
